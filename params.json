{"name":"OWASP JSON Sanitizer","tagline":"Given JSON-like content, The JSON Sanitizer converts it to valid JSON.","body":"Given JSON-like content, The JSON Sanitizer converts it to valid JSON.\r\n\r\n[Getting Started](https://github.com/mikesamuel/json-sanitizer/GettingStarted.md) - [Contact](https://github.com/mikesamuel/json-sanitizer/Contact.md)\r\n\r\n## Motivation\r\nThis can be attached at either end of a data-pipeline to help satisfy\r\nPostel's principle:\r\n\r\n> be conservative in what you do, be liberal in what you accept from others\r\n\r\nApplied to JSON-like content from others, it will produce well-formed JSON\r\nthat should satisfy any parser you use.\r\n\r\nApplied to your output before you send, it will coerce minor mistakes in\r\nencoding and make it easier to embed your JSON in HTML and XML.\r\n\r\n\r\n## Motivation\r\n\r\n![Architecture](http://json-sanitizer.googlecode.com/git/docs/JSON-Sanitizer-Arch.png)\r\n\r\nMany applications have large amounts of code that uses ad-hoc methods to generate JSON outputs.\r\nFrequently these outputs all pass through a small amount of framework code before being sent over the network.  This small amount of framework code can use this library to make sure that the ad-hoc outputs are standards compliant and safe to pass to (overly) powerful deserializers like Javascript's `eval` operator.\r\n\r\nApplications also often have web service APIs that receive JSON from a variety of sources.  When this JSON is created using ad-hoc methods, this library can massage it into a form that is easy to parse.\r\n\r\nBy hooking this library into the code that sends and receives requests and responses, this library can help software architects ensure system-wide security and well-formedness guarantees.\r\n\r\n\r\n## Input\r\n\r\nThe sanitizer takes JSON like content, and interprets it as JS eval would.\r\nSpecifically, it deals with these non-standard constructs.\r\n\r\n| Construct     | Policy                                                        |\r\n|---------------|---------------------------------------------------------------|\r\n| `'...'`       | Single quoted strings are converted to JSON strings.          |\r\n| `\\xAB`        | Hex escapes are converted to JSON unicode escapes.            |\r\n| `\\012`        | Octal escapes are converted to JSON unicode escapes.          |\r\n| `0xAB`        | Hex integer literals are converted to JSON decimal numbers.   |\r\n| `012`         | Octal integer literals are converted to JSON decimal numbers. |\r\n| `+.5`         | Decimal numbers are coerced to JSON's stricter format.        |\r\n| `[0,,2]`      | Elisions in arrays are filled with `null`.                    |\r\n| `[1,2,3,]`    | Trailing commas are removed.                                  |\r\n| `{foo:\"bar\"}` | Unquoted property names are quoted.                           |\r\n| `//comments`  | JS style line and block comments are removed.                 |\r\n| `(...)`       | Grouping parentheses are removed.                             |\r\n\r\nThe sanitizer fixes missing punctuation, end quotes, and mismatched or missing close brackets.  If an input contains only white-space then the valid JSON string `null` is substituted.\r\n\r\n\r\n## Output\r\n\r\nThe output is well-formed JSON as defined by\r\n[RFC 4627](http://www.ietf.org/rfc/rfc4627.txt).\r\nThe output satisfies three additional properties:\r\n\r\n * The output will not contain the substring (case-insensitively) `\"</script\"` so can be embedded inside an HTML script element without further encoding.\r\n * The output will not contain the substring `\"]]>\"` so can be embedded inside an XML CDATA section without further encoding.\r\n * The output is a valid Javascript expression, so can be parsed by Javascript's `eval` builtin (after being wrapped in parentheses) or by `JSON.parse`.  Specifically, the output will not contain any string literals with embedded JS newlines (U+2028 Paragraph separator or U+2029 Line separator).\r\n * The output contains only valid Unicode [scalar values](http://www.unicode.org/glossary/#unicode_scalar_value) (no isolated [UTF-16 surrogates](http://www.unicode.org/glossary/#surrogate_pair)) that are [allowed in XML](http://www.w3.org/TR/xml/#charsets) unescaped.\r\n\r\n\r\n## Security\r\n\r\nSince the output is well-formed JSON, passing it to `eval` will\r\nhave no side-effects and no free variables, so is neither a code-injection\r\nvector, nor a vector for exfiltration of secrets.\r\n\r\nThis library only ensures that the JSON string â†’ Javascript object phase has no side effects and resolves no free variables, and cannot control how other client side code later interprets the resulting Javascript object.  So if client-side code takes a part of the parsed data that is controlled by an attacker and passes it back through a powerful interpreter like `eval` or `innerHTML` then that client-side code might suffer unintended side-effects.\r\n\r\n```JavaScript\r\nvar myValue = eval(sanitizedJsonString);  // safe\r\nvar myEmbeddedValue = eval(myValue.foo);  // possibly unsafe\r\n```\r\n\r\nAdditionally, sanitizing JSON cannot protect an application from [Confused Deputy attacks](http://en.wikipedia.org/wiki/Confused_deputy_problem)\r\n\r\n```JavaScript\r\nvar myValue = JSON.parse(sanitizedJsonString);\r\naddToAdminstratorsGroup(myValue.propertyFromUntrustedSource);\r\n```\r\n\r\n# Performance\r\n\r\nThe sanitize method will return the input string without allocating a new\r\nbuffer when the input is already valid JSON that satisfies the properties\r\nabove.  Thus, if used on input that is usually well formed, it has minimal\r\nmemory overhead.\r\n\r\nThe sanitize method takes O(n) time where n is the length of the input\r\nin UTF-16 code-units.\r\n\r\n\r\n# See Also\r\n\r\n* [OWASP Project Page](https://www.owasp.org/index.php/OWASP_JSON_Sanitizer)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}